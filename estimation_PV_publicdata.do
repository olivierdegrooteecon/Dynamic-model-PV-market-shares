//////////////
/*
Regression model based on De Groote, Olivier, and Verboven, Frank. 2019. 
"Subsidies and Time Discounting in New Technology Adoption: Evidence from Solar 
Photovoltaic Systems." American Economic Review, 109 (6): 2137-72.

This file uses a publicly available dataset (instead of the confidential dataset 
of the paper) and simplified code to illustrate how to estimate the dynamic 
model with aggregate data when finite dependence applies.

This implies the following two differences with the paper:

1) source data and aggregation of capacity

The paper used confidential data on solar panel adoptions at the household 
level. Here we use a publicly available dataset at the municipality level, 
downloaded on November 14th, 2022 from the Flemish government website
https://www.vlaanderen.be/veka/energie-en-klimaatbeleid-in-cijfers/energiekaart.

In the publicly available dataset we only observe total capacity size per 
municipality (instead of per household). We therefore calculate adoption per 
capacity category, by assuming that households adopt the same capacity in a 
given month and municipality. This more aggregate approach implies few adoptions 
in the smallest and largest category. To avoid zero market shares, we add the 
2kW systems to the 4kW category and the 10kW to the 8kW category.

2) simplified code for pedagogical purposes

We kept the code simple and include only the aggregate model. Furthermore, we do 
not include the calculation of optimal instruments. Please note that all results 
in the paper (including micro-level estimation and optimal instruments) are also 
generated by STATA and do-files can be found on the AER website, but require 
confidential data to run.

We also adapted the code here by including a simplified, linear version of the 
model that was not included in the paper but yields similar policy conclusions. 
In this version the discount factor is fixed at a given value, and one estimates 
the relative valuation of upfront costs and future financial benefits.
*/

//////////////

//set path
*cd "C:\...\PV\"

//open log
cap log close
log using "Estimation_PV_publicdata",replace

//load data data
use "db_estimation_dynamic_public",clear

//describe and summarize variables in dataset
descr
sum

//monthly electricity production
gen prod=cap*0.85/12

//monthly deterioration of a PV
global deter=0.00083

//monthly electricity price increase
global elecp=0.0028148

//life expectancy in motnhs
global el=20*12

//cost instrument
gen cost=modulep*cap

//monthly GCC subsidies
gen GCC_p_prod=GCC_p*prod*GCC_factor

//declare panel
xtset cap t
sort cap t

//characteristics of terminal action (cap=4 in paper) in next period
global term 4

foreach var of varlist ///
price imtax tax_plus1 tax_plus2 tax_plus3 prod cost GCC_p_prod {
sort cap t
gen F`var'_$term=F.`var' if cap==$term
bysort t: egen max=max(F`var'_$term)
replace F`var'_$term=max
drop max
}
sort cap t
gen FGCC_d=F.GCC_d 		//does not depend on cap
gen Fp_elec=F.p_elec 	//does not depend on cap

//choice-specific constants
*if $term ~= 2 gen cap_2=cap==2
if $term ~= 4 gen cap_4=cap==4
if $term ~= 6 gen cap_6=cap==6
if $term ~= 8 gen cap_8=cap==8
*if $term ~= 10 gen cap_10=cap==10

//outcome variable
bysort t: egen adopttotal=total(adopt)
gen logdep=log(adopt/L)-log( (L-adopttotal) / L)

//CCP term
sort cap t
gen Flogshare_$term=log(F.adopt/F.L) if cap==$term
bysort t: egen max=max(Flogshare_$term)
replace Flogshare_$term=max
drop max

//drop last period
drop if t==tm(2013m1)

//define globals to be used in nonlinear models
global elec ((( 1- ({b_beta}*(1-$deter )*(1+$elecp ) ) ^($el ) ) / (1-{b_beta}*(1-$deter )*(1+$elecp ) ))*p_elec*prod)
global felec ((( 1- ({b_beta}*(1-$deter )*(1+$elecp ) ) ^($el ) ) / (1-{b_beta}*(1-$deter )*(1+$elecp ) ))*Fp_elec*Fprod_$term )
global electotal (($elec)-{b_beta}*($felec) )

global gcc ((( 1- ((1-0.0017)*{b_beta}*(1-$deter ) ) ^(GCC_d) ) / (1-(1-0.0017)*{b_beta}*(1-$deter ) ))*GCC_p_prod)
global fgcc ((( 1- ((1-0.0017)*{b_beta}*(1-$deter ) ) ^(FGCC_d) ) / (1-(1-0.0017)*{b_beta}*(1-$deter ) ))*FGCC_p_prod_$term )
global gcctotal (($gcc )-{b_beta}*($fgcc) )

global pinvtotal (price-{b_beta}*Fprice_$term)

global tax_plus (({b_beta}^12)*(imtax)+(({b_beta}^24)*tax_plus1+({b_beta}^36)*tax_plus2+({b_beta}^48)*tax_plus3))
global ftax_plus (({b_beta}^12)*(Fimtax_$term )+((({b_beta}^24)*Ftax_plus1_$term +({b_beta}^36)*Ftax_plus2_$term +({b_beta}^48)*Ftax_plus3_$term )))
global tax_plus_total ($tax_plus -{b_beta}*($ftax_plus) )

global pricevartotal ($pinvtotal -$electotal -$gcctotal -$tax_plus_total )


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////STATIC MODEL/////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

mat initial=[0.5,0.99,0,0,0]
gmm (logdep ///
+ 	(1/1000)*{b_alpha}*((price)  -   ($elec)   - ($gcc) - ($tax_plus) ) ///
- {xb: cap_* } - {b_cte}	) ///
, from(initial) instruments(cost GCC_p_prod cap_*)  ///
vce(cluster t) wmatrix(robust)

		//implicit interest rate
		nlcom 1/(_b[/b_beta]^12)-1, level(90)

		
////////////////////////////////////////////////////////////////////////////////
///////////////////////////////DYNAMIC MODEL////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
/*
Note: we do not use optimal instruments but we add the next period values of 
the cost and GCC instrument to the set of instruments to obtain more efficient 
results.  
*/

gmm (logdep ///
+ 	(1/1000)*{b_alpha}*($pricevartotal) - {b_beta}*Flogshare_$term ///
- {xb: cap_*  } - {b_cte}	) ///
, from(initial) instruments(cost GCC_p_prod Fcost_$term FGCC_p_prod_$term cap_*) ///
vce(cluster t) wmatrix(robust)
		
		//implicit interest rate
		nlcom 1/(_b[/b_beta]^12)-1, level(90)
		

////////////////////////////////////////////////////////////////////////////////
///////////////////////////////LINEAR VERSIONS OF THE MODEL/////////////////////
////////////////////////////////////////////////////////////////////////////////
/*
Here we pre-specify the discount factor to correspond to a reasonable market
interest rate. We then let upfront costs and future benefits enter both as 
product characteristics and interpret the relative difference in their estimates
as the undervaluation of the future.

Alternativally, one could also set the discount factor to be the estimate we
found in the non-linear model. We should then expect upfront costs and future 
benefits are valued the same.

We show results for both OLS and IV and for both static and dynamic.
*/		
		
//set the monthly discount factor
gen beta_rat=(1/1.03)^(1/12)	//market interest
*gen beta_rat=_b[/b_beta]		//estimate from nonlinear model
	
//calculate all components with this interest rate		
global elec ((( 1- (beta_rat*(1-$deter )*(1+$elecp ) ) ^($el ) ) / (1-beta_rat*(1-$deter )*(1+$elecp ) ))*p_elec*prod)
global felec ((( 1- (beta_rat*(1-$deter )*(1+$elecp ) ) ^($el ) ) / (1-beta_rat*(1-$deter )*(1+$elecp ) ))*Fp_elec*Fprod_$term )
global electotal (($elec)-beta_rat*($felec) )

global gcc ((( 1- ((1-0.0017)*beta_rat*(1-$deter ) ) ^(GCC_d) ) / (1-(1-0.0017)*beta_rat*(1-$deter ) ))*GCC_p_prod)
global fgcc ((( 1- ((1-0.0017)*beta_rat*(1-$deter ) ) ^(FGCC_d) ) / (1-(1-0.0017)*beta_rat*(1-$deter ) ))*FGCC_p_prod_$term )
global gcctotal (($gcc )-beta_rat*($fgcc) )

global pinvtotal (price-beta_rat*Fprice_$term)

global tax_plus ((beta_rat^12)*(imtax)+((beta_rat^24)*tax_plus1+(beta_rat^36)*tax_plus2+(beta_rat^48)*tax_plus3))
global ftax_plus ((beta_rat^12)*(Fimtax_$term )+(((beta_rat^24)*Ftax_plus1_$term +(beta_rat^36)*Ftax_plus2_$term +(beta_rat^48)*Ftax_plus3_$term )))
global tax_plus_total ($tax_plus -beta_rat*($ftax_plus) )

global pricevartotal ($pinvtotal -$electotal -$gcctotal -$tax_plus_total )
		
gen price_static=price/1000
gen benefits_static=(($elec) + ($gcc) + ($tax_plus))/1000
		
gen price_dynamic=($pinvtotal)/1000
gen benefits_dynamic=(($electotal) + ($gcctotal) + ($tax_plus_total))/1000

	
//static-OLS
reg logdep price_static benefits_static cap_*,vce(cluster t)
	
	//test of rationality
	test _b[benefits_static]=-_b[price] 	
	//% valuation of future benefits compared to upfront costs
	nlcom -_b[benefits_static]/_b[price] 	
	
	
//static-IV
ivregress 2sls logdep (price_static benefits_static = cost GCC_p_prod) cap_* ///
,vce(cluster t)
	
	//test of rationality
	test _b[benefits_static]=-_b[price] 
	//% valuation of future benefits compared to upfront costs
	nlcom -_b[benefits_static]/_b[price] 	
	
	
//dynamic-OLS
gen logdep_dynamic=logdep-beta_rat*Flogshare_$term 
reg logdep_dynamic price_dynamic benefits_dynamic cap_*,vce(cluster t) 
			
	//test of rationality
	test _b[benefits_dynamic]=-_b[price]
 	//% valuation of future benefits compared to upfront costs
	nlcom -_b[benefits_dynamic]/_b[price] 	
	
	
//dynamic-IV
ivregress 2sls logdep_dynamic (price_dynamic benefits_dynamic = ///
cost GCC_p_prod Fcost_$term FGCC_p_prod_$term) cap_*, vce(cluster t)
	
	//test of rationality
	test _b[benefits_dynamic]=-_b[price]
 	//% valuation of future benefits compared to upfront costs
	nlcom -_b[benefits_dynamic]/_b[price] 	
	
	
log close
